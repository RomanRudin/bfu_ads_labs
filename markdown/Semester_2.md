# Второй семестр:

## Содержание:
- [Список выполненных лаб](#Labs-done)
- - [Python](#Labs-done-python)
- - [C++](#Labs-done-c++)
- - [Golang](#Labs-done-golang)
- [Тексты лаб](#Labs-text)
- [Условия автомата](#Automatic-mark-conditions)
- [Объяснения лаб](#Explanation-labs)
- [Презентации от препода](#Presentations)
- [Некоторые штуки, которые я дополнительно делал](/markdown/extra_things.md)




Нашли ошибку? Сделайте [пулл-реквест](https://habr.com/ru/articles/125999/) с исправлениями - будете соавтором.

Крайне рекомендую от себя читать объяснения к лабам. Особенно те объяснения, что написаны мной вручную, те, где даны не только ссылки. Там информация изложена в максимально понятном ключе и должна достаточно просто восприниматься.
 
Если ссылка с выполненной лабы ведёт на объяснение лабы - просто почитайте там дальше, видимо, есть несколько вариантов её выполнения и дальше таам будут ссылки.


<a name="Labs-done">

# Выполненные (и проверенные Балабановым) работы
</a>
<a name="Labs-done-python">

### Python <img src="https://github.com/devicons/devicon/blob/master/icons/python/python-original.svg"  title="Python" alt="Python" width="40" height="40"/>&nbsp;
</a>

1. [x] [Алгоритм проверки точек на выпуклый многоугольник](/Semester_2/Lab1/Grahams_algorythm.py)
2. [x] [Алгоритм проверки точек на вершины вложенных треугольников](/Semester_2/Lab2/lab2.py)
3. [x] [Алгоритм поиска по образцу с помощью конечного автомата](/Semester_2/Lab3/Finite_automata_patter_searching_algorythm.py)
4. [x] [Алгоритм Кнута-Морриса-Пратта для поиска по образ](/Semester_2/Lab4/KMP_algorythm.py)
5. [x] [Алгоритм Бойера-Мура для поиска по образцу](/Semester_2/Lab5/BM_algorythm_bad_character.py)
6. [x] [Алгоритм Рабина для поиска по образцу](/Semester_2/Lab6/RK_algorythm.py) 
7. [x] [Задача о самом большом подмассиве](#lab7)
8. [x] [Проблема размена монет](/Semester_2/Lab8/coin_exchange.py)
9. [x] [Задача коммивояжера](/Semester_2/Lab9/travelling_salesman.py)
10. [x] [Задача о бросании яиц](/Semester_2/Lab10/egg_drop.py)
11. [x] [Задача о раскраске графа](/Semester_2/Lab11/graph_painting.py)
12. [x] [Дискретная задача о рюкзаке](/Semester_2/Lab12/backpack.py) 
13. [x] [Задача о раскладке по ящикам](/Semester_2/Lab13/boxes.py)


<a name="Labs-done-c++">

### C++ <img src="https://github.com/devicons/devicon/blob/master/icons/cplusplus/cplusplus-original.svg"  title="C++" alt="C++" width="40" height="40"/>&nbsp;
</a>

1. [x] [Алгоритм проверки точек на выпуклый многоугольник](/Semester_2/Lab1/lab1.cpp)
2. [x] [Алгоритм проверки точек на вершины вложенных треугольников](/Semester_2/Lab2/lab2.cpp)
3. [x] [Алгоритм поиска по образцу с помощью конечного автомата](/Semester_2/Lab3/lab3.cpp)
4. [x] [Алгоритм Кнута-Морриса-Пратта для поиска по образ](/Semester_2/Lab4/lab4.cpp)
5. [x] [Алгоритм Бойера-Мура для поиска по образцу](/Semester_2/Lab5/lab5.cpp)
6. [x] [Алгоритм Рабина для поиска по образцу](/Semester_2/Lab6/lab6.cpp)
7. [X] [Задача о самом большом подмассиве](/Semester_2/Lab7/lab7.cpp)
8. [X] [Проблема размена монет](/Semester_2/Lab8/lab8.cpp)
9. [X] [Задача коммивояжера](/Semester_2/Lab9/lab9.cpp)
10. [x] [Задача о бросании яиц](/Semester_2/Lab10/lab10.cpp)
11. [x] [Задача о раскраске графа](/Semester_2/Lab11/lab11.cpp)
12. [x] [Дискретная задача о рюкзаке](/Semester_2/Lab12/lab12.cpp)
13. [X] [Задача о раскладке по ящикам](/Semester_2/Lab13/lab13.cpp)


<a name="Labs-done-golang">

### Golang <img src="https://github.com/devicons/devicon/blob/master/icons/go/go-original.svg"  title="golang" alt="golang" width="40" height="40"/>&nbsp;
</a>

1. [x] [Алгоритм проверки точек на выпуклый многоугольник](/Semester_2/Lab1/main.go)
2. [ ] [Алгоритм проверки точек на вершины вложенных треугольников]()
3. [x] [Алгоритм поиска по образцу с помощью конечного автомата](/Semester_2/Lab3/main.go)
4. [x] [Алгоритм Кнута-Морриса-Пратта для поиска по образ](/Semester_2/Lab4/main.go)
5. [x] [Алгоритм Бойера-Мура для поиска по образцу](/Semester_2/Lab5/main.go)
6. [x] [Алгоритм Рабина для поиска по образцу](/Semester_2/Lab6/main.go)
7. [x] [Задача о самом большом подмассиве](/Semester_2/Lab7/main.go)
8. [x] [Проблема размена монет](/Semester_2/Lab8/main.go)
9. [ ] [Задача коммивояжера]()
10. [x] [Задача о бросании яиц](/Semester_2/Lab10/main.go)
11. [ ] [Задача о раскраске графа]()
12. [ ] [Дискретная задача о рюкзаке]()
13. [ ] [Задача о раскладке по ящикам]()







<a name="Labs-text">

# Текст лаб
</a>

[Вордовский документ с тем же текстом лаб](/docs/Zadania_2_semestr_2024-2025.docx)


### Нахождение выпуклой оболочки множества точек

1. В данной задаче требуется ввести N точек своими координатами (x,y). Затем требуется определить, существует ли выпуклая оболочка заданного множества точек. При этом можно использовать: или алгоритм Грэхема, или алгоритм Джарвиса, или метод «разделяй и властвуй»

Записать алгоритмы нахождения точек пересечения двух прямых, прямой и отрезка, двух отрезков, прямой и окружности, отрезка и окружности, двух окружностей. Данные алгоритмы используются при решении следующей задачи:

2.	Дано N точек координатами (X,Y). Выяснить, есть ли в этом множестве точек координаты вложенных друг в друга треугольников.


### Поиск по образцу

3.	Реализовать алгоритм поиска по образцу с помощью конечного автомата

4.	Реализовать алгоритм Кнута-Морриса-Пратта для поиска по образцу

5.	Реализовать алгоритм Бойера-Мура для поиска по образцу

6.	Реализовать алгоритм Рабина для поиска по образцу


### Динамическое программирование

7.	Задача о самом большом подмассиве: поиск непрерывного подмассива в одномерном массиве чисел с наибольшей суммой.

8.	Проблема размена монет: поиск количества способов внести сдачу на заданную сумму денег, используя заданный набор номиналов монет.

9.	Задача коммивояжера - поиск кратчайшего возможного маршрута, который проходит через заданный набор городов и возвращается в начальный город. Маршруты заданы матрицей связности.

10.	Задача о бросании яиц: Дано 100-этажное здание. Если яйцо сбросить с высоты N-го этажа (или с большей высоты), оно разобьется. Если его бросить с любого меньшего этажа, оно не разобьется. У вас есть два яйца. Найдите N за минимальное количество бросков.


### NP-полные задачи

11.	Решить задачу о раскраске графа.

12.	Решить дискретную задачу о рюкзаке.

13.	Решить задачу о раскладке по ящикам.






<a name="Automatic-mark-conditions">

# Условия автомата
</a>

Добрый день 
Пишу требования к лабораторным и автоматам 
Также, сдаем на любом языке программирования. По автоматам – будут только 5ки, чтобы ее получить, нужно каждую лабораторную реализовывать самостоятельно и хорошо разбираться в лабораторной теме. Также для автомата в некоторых лабораторных может потребоваться реализовать более сложный алгоритм 

1. -я лабораторная. Сама по себе не из простых. В задании написано, проверить, существует ли выпуклая оболочка. Это не совсем корректно(она существует, если точек больше двух и они не лежат на прямой). Нужно найти саму оболочку и вывести точки, входящие в нее. Алгоритм на выбор – Грэхем, Джарвис 
 
2. -я лабораторная.  "Наивный" алгоритм перебора 6 точек пройдет не на автомат. На автомат нужно использовать какие-то идеи, чтобы уменьшить временную сложность алгоритма

3. -я. Достаточно реализовать автомат, который будете рассматривать на лекции

4. -я. КМП – здесь нужно использовать префикс-функцию. Нужно понимать, что она значит (её определение). На автомат понимать, как она строится (доказательство времени работы необязательно)

5. -я. БМ – здесь просто реализовать этот алгоритм

6. -я. РК – здесь хэши, на автомат время работы должно быть линейное (пересчет хеша за O(1)), не на автомат не буду строго смотреть на это

7. -я. Либо придумать динамическое программирование, либо использовать алгоритм Кадана. Сложность O(n).

8. -я. Реализовать динамическое программирование. 

9. -я. Не на автомат - перебором. На автомат – динамическое программирование по подмножествам.

10. -я. Уметь объяснить решение.

11. -я. Перебор.

12. -я. Перебор или динамическое программирование.

13. -я. Перебор - не на автомат. Динамическое программирование по подмножествам - на автомат.







<a name="Explanation-labs">

# Объяснение лаб
</a>

### Нахождение выпуклой оболочки множества точек

1. [Стандартное решение Python](/Semester_2/Lab1/Grahams_algorythm.py), [решение Python с визуализацией через matplotlib](/Semester_2/Lab1/Grahams_algorythm_with_visualisation.py)

[Почитать про алгоритм](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%93%D1%80%D1%8D%D1%85%D0%B5%D0%BC%D0%B0#:~:text=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%20%D0%93%D1%80%D1%8D%D1%85%D0%B5%D0%BC%D0%B0%20%E2%80%94%20%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%20%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D1%8F,%D0%B8%D1%85%20%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B0%20%D0%BF%D1%80%D0%BE%D1%82%D0%B8%D0%B2%20%D1%87%D0%B0%D1%81%D0%BE%D0%B2%D0%BE%D0%B9%20%D1%81%D1%82%D1%80%D0%B5%D0%BB%D0%BA%D0%B8)

Как вариант - использование алгоритма Джарвиса (но у меня реализован алгоритм Грэхема. Но объяснять его мне лень)

Пусть даны точки A(0,0); B(1,1); C(2,2); D(0,3); E(3,0); F(3,3).
Сначала выбираем самую левую точку, в нашем случае A(0,0) (start)
Далее ищем самую правую точку: ищется по принципу найти
минимальный угол между start и следующей точкой. В нашем случае
самая правая - E(3,0). Далее повторяем эти шаги, пока наш контур
не замкнётся (E(3,0) --> F(3,3) --> D(0, 3) --> A(0, 0)). 

Если попроще: 
Пусть у нас есть доска и гвозди, вбитые в неё (произвольно).
Нам необходимо обернуть верёвкой гвозди так, чтобы она охватила
все гвозди, образуя минимальную выпуклую фигуру. По алгоритму
Джарвиса мы делаем это последовательно (см. выше :))



2. Алгоритм работы программы:

- Генерация точек
Создаётся список из n случайных точек Point(x, y).

- Построение треугольников
Перебираются все комбинации из 3 точек.
Коллинеарные точки отбрасываются.

- Создание R-дерева
Для каждого треугольника вычисляется ограничивающий прямоугольник (AABB).
Все треугольники индексируются в R-дерево для быстрого поиска.

- Поиск вложенных треугольников
Треугольники сортируются по убыванию площади.





### Поиск по образцу

3.  Для реализации конечного автомата была использована префикс-функция.

Конечный автомат для строки pattern — это автомат, где:

- Состояния соответствуют длине совпавшего префикса (от 0 до m, где m — длина образца).
- Переходы между состояниями определяются по символам текста.
- Если автомат достигает состояния m, значит, найдено вхождение образца.

Префикс-функция используется для эффективного построения переходов автомата.

Время работы: O(n + m).

[ППочитать?](https://translated.turbopages.org/proxy_u/en-ru.ru.59cc7ff6-6787f565-c87772e8-74722d776562/https/www.geeksforgeeks.org/finite-automata-algorithm-for-pattern-searching/)



4. Префикс-функция — это число, которое вычисляет длину наибольшего префикса подстроки, 
совпадающего с её суффиксом, но не равного самой подстроке. Она помогает алгоритму КМП "перепрыгивать" уже проверенные части строки, ускоряя поиск.

Время работы алгоритма:
O(n + m), где n - длина текста, m - длина паттерна.

Простой пример:
Рассмотрим строку "abab"
- π[0] = 0 (у "a" нет нетривиального суффикса).

- π[1] = 0 (у "ab" суффикс "b" ≠ префикс "a").

- π[2] = 1 (у "aba" суффикс "a" совпадает с префиксом "a").

- π[3] = 2 (у "abab" суффикс "ab" совпадает с префиксом "ab").

[Читаем посложнее](https://habr.com/ru/articles/307220/), [Читаем попроще очень хорошие статейки](https://habr.com/ru/articles/658779/)



5. [Читаем очень хорошие статейки](https://habr.com/ru/articles/660767/). Мы рассматривали на паре только первую эвристику (правило плохого символа).

Алгоритм Бойера-Мура — это быстрый способ поиска подстроки в тексте. Он работает умнее, чем наивный перебор, потому что пропускает заведомо ненужные сравнения.

Алгоритм сравнивает образец с тексом справа-налево. Использует два правила:
- Правило плохого символа:
Сдвигаем образец, чтобы плохой символ в тексте совпал с ближайшим таким же символом в образце. Иначе - сдвиг образца целиком за него.

- Правило хорошего суффикса:
Если часть образца совпала, но далее ошибка, то сдвигаем образец так, чтобы совпавший кусок
совпал снова в другом месте.

Преимущества: алгоритм пропускает много символов прыжками, не перебирает всё подряд. Эффективен для больших текстов.

Время работы: O(n/m).



6. Алгоритм Рабина-Карпа направлен на поиск в строке нашего заданного паттерна, используя хеширование, то есть преобразуем строку в число. Работа алгоритма O(n + m), в нашем случае O(1).

Пример:
В строке ABABDABACDABABCABAB нужно найти ABD. Преобразуем ABD 
в 123. Берём первые три символа ABA их хэш не совпал с 123.
Сдвигаем на 1, BAB не совпал хэш. Сдвигаем ещё раз на 1 ABD.
ГООООООЛ!!!! Позиция 2.

Формула пересчёта хэша за O(1):
hash_window = (d * (hash_window - ord(text[i]) * h) + ord(text[i + m])) % q,
где hash_window - хэш текущего окна;
text[i] - символ старого окна;
text[i + m] - новый символ в конце;
d - размер алфавита;
q - число, чтобы хэш не становился очень большим;
h - сами догадывайтесь уууахахахах... да. h - переменная для эффективного пересчёта хэша при сдвиге окна.
h = d^(m - 1) % q, где m - длина паттерна.

[Читаем очень хорошие статейки](https://habr.com/ru/articles/662678/)





### Динамическое программирование

<a href="#lab7">

7. Есть два варианта: [динамическое программирование](/Semester_2/Lab7/the_largest_subarray.py) и [алгоритм Кадана](/Semester_2/Lab7/kadan_algorythm.py).

Объяснение алгоритма Кадане:

Простыми словами:
Пусть нам дан массив чисел, представим, что эти числа обозначают прибыль на каждый наш день.
Нам нужно найти интервал, когда максимальная наша прибыль продержалась дольше всего.

Умно:
Проходим по всем числам слева-направо. Берём первое число, оно у нас пока самое большое.
Далее рассматриваем следующее число, если оно больше, чем сумма предыдущих + текущее число,
то мы теперь запоминаем это число. И так проверяем далее, пока добавление числа увеличивает
общую сумму. Выводим наш интервал. Так в первом примере наш подмассив - [4, -1, 2, 1].
Число после 1, а именно -5 уже нарушает наш период max(-5, 6-5) = 1, именно поэтому такой
подмассив!

[Статья?](https://proglib.io/p/25-algoritmov-dinamicheskogo-programmirovaniya-kotorye-dolzhen-znat-kazhdyy-programmist-2023-05-30)
</a>



8. Ну... это программа и она работает типа...

Время работы: O(S*m)

dp[i] хранит количество способов разменять сумму i
Осуществляется перебор всех номиналов монет по одному
Программа заполняет по очереди каждый индекс массива:
Так, к примеру...
Обработка монеты 1
    dp[1] += dp[0] → dp = [1, 1, 0, 0, 0, 0]
    dp[2] += dp[1] → dp = [1, 1, 1, 0, 0, 0]
    dp[3] += dp[2] → dp = [1, 1, 1, 1, 0, 0]
    dp[4] += dp[3] → dp = [1, 1, 1, 1, 1, 0]
    dp[5] += dp[4] → dp = [1, 1, 1, 1, 1, 1]



9. Ты думал, здесь что-то будет?



10. Делаем эксперимент-имитацию падения яйца с случайного этажа.

Берём начальный шаг = 14 (из формулы, поищите статйеку на Хабре, я её потерял, увы). Каждый раз уменьшаем этот шаг на 1, пока яйцо не разобьётся, то есть
14 - 27 - 39 - 50 и т.д. Если яйцо разбилось на 27 этаже, значит проверяем промежуток между 15 и 27, пока не найдём 
начальный этаж, с которого оно начинает разбиваться.
P.S. этаж, где яйцо разобьётся выбирает сама программа, мы определяем кол-во шагов, необходимых
для проверки этажа, с которого оно разбилось!





### NP-полные задачи

11. [Статья?](https://publications.hse.ru/pubs/share/folder/0rhqzr8ukk/133671897.pdf)



12. Сложность алгоритма: O(2^n).
Алгоритм перебирает все возможные варианты вещей, которые можно вместить в рюкзак весом capacity.
Перебираем values - список стоимости предметов, weights - список веса предметов, и находим оптимальный вариант.



13. Необходимо распределить предметы по минимальному кол-ву ящиков.

Сложность: O(3^n)

Сначала генерируем все возможные подмножества предметов, которые могут поместиться в 1 ящик.
dp[mask] хранит минимальное количество ящиков, необходимое для упаковки предметов, заданных
битовой маской mask. Для каждой маски пытаемся добавить допустимое подмножество предметов,
которое не пересекается с текущей маской. Обновляем dp для новой маски, если нашлось более
оптимальное решение.
 






<a name="Presentations">

# Презентации от преподавателя за семестр
</a>

- [А ИХ НЕТ ПОТОМУ ЧТО БЛИН]()
